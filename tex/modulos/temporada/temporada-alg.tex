\algoritmoI{Iniciar}{\param{in}{sl}{sistemaLaboral}}{estrT}
{
	\state res.sistema \asig sl								\inlineC{1}
	\state res.paritariasAbiertas \asig Vacío()				\inlineC{1}
	\state res.acuerdosVigentesPorGrupo \asig Vacía()		\inlineC{1}
	\state res.\#aperturas \asig Vacía()					\inlineC{1}
	\state

	\state InicializarAcuerdosVigentesPorGrupo(res)			\inlineC{\#gremios}
	\state Inicializar\#Aperturas(res)						\inlineC{\#gremios}
}
{\#gremios}
{ Se guarda el sistema laboral, y se inicializan los contenedores de paritarias y acuerdos y los contadores de aperturas. Las asignaciones se realizan en tiempo constante y las inicializaciones en O(\#gremios), entonces la función es O(\#gremios). }

\algoritmoI{AbrirParitaria}{\param{in/out}{ tmp}{estrT}, \param{in}{gr}{gremio}, \param{in}{p}{nat}, \param{in}{t}{nat}, \param{in}{es}{conj(empresa)}}{}
{
	\If{0 \menor Obtener\#Aperturas(tmp, gr)}					\inlineC{1}
		\state RemoverAcuerdo(tmp, gr)							\inlineC{0}
	\endif
	\state

	\state AgregarParitaria(tmp, NuevaParitaria(gr, p, t))		\inlineC{1}
}
{0}
{ Cuando la paritaria de un gremio abre por primera vez, no existe acuerdo previo en el sistema y su contador de aperturas es nulo; en ese caso, la operación se realiza en O(1). Para el caso general, la complejidad temporal de la operación queda determinada por la función RemoverAcuerdo. }

\algoritmoI{CerrarAcuerdo}{\param{in/out}{ tmp}{estrT}, \param{in}{gr}{gremio} , \param{in}{pcj}{nat}}{}
{

	\state \var{itLista(acuerdo)}{itAcuerdos} \asig CrearIt(ObtenerAcuerdosDeAliados(tmp, gr))		\inlineC{1}
	\while{HaySiguiente(itAcuerdos) \lyl ObtenerPorcentaje(Siguiente(itAcuerdos)) \menor pcj}		\inlineC{1}
		\state

		\state AgregarParitaria(tmp, ObtenerParitaria(Siguiente(itAcuerdos)))		\inlineC{1}

		\state EliminarSiguiente(itAcuerdos)										\inlineC{1}

		\state
		\state Avanzar(itAcuerdos)													\inlineC{1}
	\endwhile
	\state

	\state \var{paritaria}{pa} \asig RemoverParitaria(tmp, gr)				\inlineC{\#paritarias\_abiertas}
	\state AgregarComoSiguiente(itAcuerdos, NuevoAcuerdo(pa, pcj))			\inlineC{1}
}
{\#acuerdos\_menores + \#paritarias\_abiertas}
{La función ObtenerAcuerdosDeAliados devuelve la lista de los aliados del gremio afectado en tiempo constante; luego, la creación del iterador para esta lista también se realiza en O(1). 

\hspace{10pt} La evaluación de la guarda y el cuerpo del ciclo se realizan en tiempo constante, ya que todas estas funciones se realizan en O(1): HaySiguiente, ObtenerPorcentaje, Siguiente, AgregarParitaria, ObtenerParitaria, EliminarSiguiente, Avanzar, \lyl, \menor.

\hspace{10pt} La lista de acuerdos de aliados se itera secuencialmente hasta encontrar un acuerdo con un porcentaje de aumento mayor o igual al logrado en el nuevo acuerdo. Como la lista se encuentra ordenada de menor a mayor según el valor del aumento, esto significa que se realizarán exactamente \#acuerdos\_menores iteraciones. En cada una de ellas, se reabre la paritaria de un acuerdo de menor aumento, efectivizando el comportamiento automático.

\hspace{10pt} La operación RemoverParitaria es lineal en la cantidad de paritarias abiertas, y por último, agregar un acuerdo a la lista mediante el iterador se realiza en tiempo constante. Por lo tanto, la función tiene una complejidad temporal de O(\#acuerdos\_menores + \#paritarias\_abiertas).  }

\algoritmoI{Reabrir}{\param{in/out}{ tmp}{estrT},  \param{in}{gr}{gremio}}{}
{
	\state \var{paritaria}{pa} \asig RemoverAcuerdo(tmp, gr)			\inlineC{0}

	\state AgregarParitaria(tmp, pa)									\inlineC{1}
}
{0}
{\lipsum[\arabic{lipsumcounter}]\addtocounter{lipsumcounter}{1}}

\algoritmoI{Gremios}{\param{in}{tmp}{estrT}}{conj(gremio)}
{
	\state res \asig ObtenerGremios(tmp.sl)								\inlineC{1}
}
{1}
{ Se devuelve por referencia el conjunto de gremios del sistema, lo cual toma tiempo constante. }

\algoritmoI{EnParitarias}{\param{in}{tmp}{estrT}, \param{in}{gr}{gremio}}{bool}
{
	\state \var{itConj(paritaria)}{itParitarias} \asig CrearIt(tmp.paritariasAbiertas)		\inlineC{0}
	\while{HaySiguiente(itParitarias) \lyl ObtenerGremio(Siguiente(itParitarias)) \distinto gr}		\inlineC{0}
		\state
		\state Avanzar(itParitarias)				\inlineC{0}
	\endwhile
	\state

	\state res \asig HaySiguiente(itParitarias)		\inlineC{0}
}
{0}
{\lipsum[\arabic{lipsumcounter}]\addtocounter{lipsumcounter}{1}}

\algoritmoI{GremiosNegociando}{\param{in}{tmp}{estrT}}{conj(gremio)}
{
	\state res \asig Vacío()		\inlineC{0}
	\state

	\state \var{itConj(paritaria)}{itParitarias} \asig CrearIt(tmp.paritariasAbiertas)		\inlineC{1}
	\while{HaySiguiente(itParitarias)}										\inlineC{1}
		\state
		\state Agregar(res, ObtenerGremio(Siguiente(itParitarias)))			\inlineC{0}
		
		\state
		\state Avanzar(itParitarias)										\inlineC{1}
	\endwhile
}
{0}
{\lipsum[\arabic{lipsumcounter}]\addtocounter{lipsumcounter}{1}}

\algoritmoI{EmpresasNegociando}{\param{in}{tmp}{estrT}}{conj(empresa)}
{
	\state res \asig Vacío()		\inlineC{1}
	\state

	\state \var{itConj(paritaria)}{itParitarias} \asig CrearIt(tmp.paritariasAbiertas)		\inlineC{1}
	\while{HaySiguiente(itParitarias)}						\inlineC{1}
		\state
		\state conj(empresa) empresasParitaria \asig ObtenerEmpresas(ObtenerGremio(Siguiente(itParitarias)))		\inlineC{0}
		\state res \asig Union(res, empresasParitaria)		\inlineC{0}

		\state
		\state Avanzar(itParitarias)						\inlineC{1}
	\endwhile
}
{0}
{\lipsum[\arabic{lipsumcounter}]\addtocounter{lipsumcounter}{1}}

\algoritmoI{TrabajadoresNegociando}{\param{in}{tmp}{estrT}}{nat}
{
	\state res \asig 0		\inlineC{1}
	\state

	\state \var{itConj(paritaria)}{itParitarias} \asig CrearIt(tmp.paritariasAbiertas)		\inlineC{1}
	\while{HaySiguiente(itParitarias)}					\inlineC{1}
		\state

		\state \var{nat}{\#afiliadosParitaria} \asig Obtener\#Afiliados(ObtenerGremio(Siguiente(itParitarias)))		\inlineC{1}
		\state res \asig res + \#afiliadosParitaria		\inlineC{1}

		\state
		\state Avanzar(itParitarias)					\inlineC{1}
	\endwhile
}
{ \#paritarias\_abiertas }
{ Todas las operaciones se realizan en tiempo constante; como se realiza una iteración por cada paritaria abierta, la función es O(\#paritarias\_abiertas). }

\algoritmoI{GremioConflictivo}{\param{in}{tmp}{estrT}}{gremio}
{
	\state \var{itConj(gremio)}{itGremios} \asig CrearIt(Gremios(tmp))						\inlineC{0}
	\state

	\state \var{gremio}{gremioConflictivo} \asig Siguiente(itGremios)				\inlineC{0}
	\state \var{nat}{maxAperturas} \asig Obtener\#Aperturas(tmp, gremioConflictivo)		\inlineC{0}
	\state Avanzar(itGremios)																\inlineC{0}
	\state

	\while{HaySiguiente(itGremios)}																\inlineC{0}
		\state

		\state \var{nat}{\#aperturas} \asig Obtener\#Aperturas(tmp, Siguiente(itGremios))		\inlineC{0}

		\If{maxAperturas \menor \#aperturas}							\inlineC{0}

			\state maxAperturas \asig \#aperturas						\inlineC{0}
			\state gremioConflictivo \asig Siguiente(itGremios)			\inlineC{0}
		\endif

		\state
		\state Avanzar(itGremios)										\inlineC{0}
	\endwhile
	\state

	\state res \asig gremioConflictivo									\inlineC{0}
}
{0}
{\lipsum[\arabic{lipsumcounter}]\addtocounter{lipsumcounter}{1}}

\algoritmoI{InicializarAcuerdosVigentesPorGrupo}{\param{in/out}{ tmp}{estrT}}{}
{
	\state \var{nat}{indice} \asig 0									\inlineC{1}
	\while{indice \menor Obtener\#GruposDeAliados(tmp.sistema)}			\inlineC{1}
		\state

		\state tmp.acuerdosVigentesPorGrupo[indice] \asig Vacía()		\inlineC{1}

		\state
		\state indice \asig indice + 1									\inlineC{1}
	\endwhile

}
{\#gremios}
{ La operación inicial, la evaluación de la guarda, y el cuerpo del ciclo se realizan en tiempo constante. Como el ciclo se repite tantas veces como \#grupos\_de\_aliados, la función es O(\#grupos\_de\_aliados). Pero a su vez, la cantidad de grupos de aliados es igual a la cantidad de gremios en el peor caso, entonces la función es O(\#gremios). }

\algoritmoI{Inicializar\#Aperturas}{\param{in/out}{ tmp}{estrT}}{}
{
	\state \var{nat}{indice} \asig 0					\inlineC{1}
	\while{indice \menor Cardinal(Gremios(tmp))}		\inlineC{1}
		\state

		\state tmp.\#aperturas[indice] \asig 0			\inlineC{1}

		\state
		\state indice \asig indice + 1					\inlineC{1}
	\endwhile
}
{\#gremios}
{ La operación inicial, la evaluación de la guarda, y el cuerpo del ciclo se realizan en tiempo constante. Como el ciclo se repite tantas veces como \#gremios, la función es O(\#gremios). }

\algoritmoI{AgregarParitaria}{\param{in/out}{ tmp}{estrT}, \param{in}{pa}{paritaria}}{}
{
	\state AgregarRapido(tmp.paritariasAbiertas, pa)		\inlineC{1}
}
{1}
{ La función debe utilizarse con la certeza de que la paritaria que se va a agregar no se encuentra abierta, para no degenerar el conjunto paritariasAbiertas. La paritaria se agrega al conjunto por copia, la cual se realiza en O(copy(pa)), pero esto es O(1) ya que solo requiere copiar la referencia al gremio, y dos valores de tipo nat. }

\algoritmoI{RemoverParitaria}{\param{in/out}{ tmp}{estrT}, \param{in}{gr}{gremio}}{paritaria}
{
	\state \var{itConj(paritaria)}{itParitarias} \asig CrearIt(tmp.paritariasAbiertas)		\inlineC{0}
	\while{ObtenerGremio(Siguiente(itParitarias)) \distinto gr}		\inlineC{0}
		\state
		\state Avanzar(itParitarias)								\inlineC{0}
	\endwhile
	\state

	\state res \asig Siguiente(itParitarias)						\inlineC{0}

	\state EliminarSiguiente(itParitarias)							\inlineC{0}
}
{0}
{\lipsum[\arabic{lipsumcounter}]\addtocounter{lipsumcounter}{1}}

\algoritmoI{RemoverAcuerdo}{\param{in/out}{ tmp}{estrT}, \param{in}{gr}{gremio}}{paritaria}
{
	\state \var{itLista(acuerdo)}{itAcuerdos} \asig CrearIt(ObtenerAcuerdosDeAliados(tmp, gr))		\inlineC{1}
	\while{ObtenerGremio(Siguiente(itAcuerdos)) \distinto gr}		\inlineC{0}
		\state
		\state Avanzar(itAcuerdos)  								\inlineC{1}
	\endwhile
	\state

	\state res \asig ObtenerParitaria(Siguiente(itAcuerdos))		\inlineC{1}

	\state EliminarSiguiente(itAcuerdos)							\inlineC{1}
}
{0}
{\lipsum[\arabic{lipsumcounter}]\addtocounter{lipsumcounter}{1}}

\algoritmoI{ObtenerAcuerdosDeAliados}{\param{in}{tmp}{estrT}, \param{in}{gr}{gremio}}{lista(acuerdo)}
{
	\state \var{idGrupo}{id} \asig ObtenerIdGrupoAliados(tmp.sistema, gr)		\inlineC{1}

	\state res \asig tmp.acuerdosVigentesPorGrupo[id]							\inlineC{1}
}
{1}
{ El módulo SistemaLaboral permite obtener el id de grupo de un gremio en tiempo constante, y luego solo es necesario leer la posición correspondiente en el vector acuerdosVigentesPorGrupo. }

\algoritmoI{Obtener\#Aperturas}{\param{in}{tmp}{estrT}, \param{in}{gr}{gremio}}{nat}
{
	\state \var{idGremio}{id} \asig ObtenerId(gr)			\inlineC{1}

	\state res \asig tmp.\#aperturas[id]					\inlineC{1}
}
{1}
{ El tiempo de lectura de la i-ésima posición de un vector es constante, entonces la función permite conocer la cantidad de aperturas de un gremio en O(1). }