\algoritmoI{NuevoSistemaLaboral}{\param{in/out}{gs}{conj(gremio)}}{estrS}
{
	\state AsignarIds(gs)								\inlineC{\#gremios}
	\state res.gremios \asig gs 						\inlineC{1}
	\state
	\state res.gruposDeAliados \asig Vacía()			\inlineC{1}
	\state InicializarGruposDeAliados(res)				\inlineC{\#gremios}
}
{\#gremios}
{Asigna id's consecutivos a los gremios, comenzando en 0, y luego le asigna a cada gremio un id de grupo igual a su id propio (esto garantiza que los gremios no tengan aliados inicialmente, y que sus id's de grupo sean consecutivos, comenzando en 0). }

\algoritmoI{AliarGremios}{\param{in/out}{sl}{estrS}, \param{in}{gr1}{gremio}, \param{in}{gr2}{gremio}}{}
{
	\state \var{idGrupo}{idGrupoG1} \asig ObtenerIdGrupoDeAliados(sl, gr1)			\inlineC{1}
	\state \var{idGrupo}{idGrupoG2} \asig ObtenerIdGrupoDeAliados(sl, gr2)			\inlineC{1}
	\state 

	\If{idGrupoG1 \distinto idGrupoG2}												\inlineC{1}
		\state UnificarGruposDeAliados(sl, idGrupoG1, idGrupoG2)					\inlineC{\#gremios}
	\endif
}
{\#gremios}
{ Asegura que todos los gremios aliados a uno u otro de los gremios que contraen la alianza pasen a tener el mismo id de grupo (manteniendo la propiedad de que los id's de grupo deben ser consecutivos, comenzando en 0).

\hspace{10pt} Si la operación es no redundante (los gremios no eran aliados aún), el costo de esta operación queda determinado por la función UnificarGruposDeAliados. }

\algoritmoI{ObtenerGremios}{\param{in}{sl}{estrS}}{conj(gremio)}
{
	\state res \asig sl.gremios								\inlineC{1}
}
{1}
{ Se devuelve el conjunto de gremios por referencia, lo cual toma tiempo constante. }

\algoritmoI{Obtener\#GruposDeAliados}{\param{in}{sl}{estrS}}{nat}
{
	\state res \asig MaximoIdGrupoDeAliados(sl)			\inlineC{\#gremios}
}
{\#gremios}
{La cantidad de grupos de aliados en el sistema queda determinado por el máximo id de grupo.}

\algoritmoI{ObtenerIdGrupoDeAliados}{\param{in}{sl}{estrS}, \param{in}{gr}{gremio}}{idGrupo}
{
	\state res \asig sl.gruposDeAliados[ObtenerId(gr)]			\inlineC{1}
}
{1}
{}

\algoritmoI{ModificarIdGrupoDeAliados}{\param{in/out}{sl}{estrS}, \param{in}{gr}{gremio}, \param{in}{id}{idGrupo}}{}
{
	\state sl.gruposDeAliados[ObtenerId(gr)] \asig id			\inlineC{1}
}
{1}
{}

\algoritmoI{AsignarIds}{\param{in}{gs}{conj(gremio)}}{}
{
	\state \var{nat}{id} \asig 0											\inlineC{1}
	\state

	\state \var{itConj(gremio)}{itGremios} \asig CrearIt(res.gremios)		\inlineC{1}
	\while{ HaySiguiente(itGremios) }
		\state
		
		\state GuardarId(Siguiente(itGremios), id)							\inlineC{1}
		\state id \asig id + 1												\inlineC{1}
		
		\state
		\state Avanzar(itGremios)											\inlineC{1}
	\endwhile
}
{ \#gremios }
{ Asigna un id a cada gremio, comenzando en 0 y de forma consecutiva.

\hspace{10pt} Como esta operación se puede realizar en tiempo constante (notar que Siguiente devuelve una referencia y por lo tanto no se realiza una copia del gremio), la función es O(\#gremios). }

\algoritmoI{InicializarGruposDeAliados}{\param{in/out}{sl}{estrS}}{}
{
	\state \var{itConj(gremio)}{itGremios} \asig CrearIt(sl.gremios)		\inlineC{1}
	\while{ HaySiguiente(itGremios) }										\inlineC{1}
		\state
		
		\state \var{gremio}{gr} \asig Siguiente(itGremios)					\inlineC{1}		
		\state Agregar(sl.gruposDeAliados, ObtenerId(gr), ObtenerId(gr))	\inlineC{1}

		\state
		\state Avanzar(itGremios)											\inlineC{1}
	\endwhile
}
{ \#gremios }
{ Asigna a cada gremio del sistema un id de grupo igual a su id propio; esto significa asignar el valor id-del-gremio a la posición id-del-gremio del vector gruposDeAliados. Como los id's de los gremios son consecutivos y comienzan en 0 (según el órden provisto por su iterador), la función Agregar del módulo Vector se llama con índices consecutivos y no se indefine.

\hspace{10pt} El costo de esta operación es el costo de agregar \emph{\#gremios} elementos al vector. Esta operación puede ser no constante si es necesario duplicar el tamaño del vector; sin embargo, el costo amortizado de insertar \emph{n} elementos al final de un arreglo dinámico es O(n), por lo que la operación es O(\#gremios). }

\algoritmoI{UnificarGruposDeAliados}
{\param{in/out}{sl}{estrS}, \param{in}{id1}{idGrupo}, \param{in}{id2}{idGrupo}}{}
{
	\state \var{idGrupo}{idMenor} \asig Min(id1, id2)						\inlineC{1}
	\state \var{idGrupo}{idMayor} \asig Max(id1, id2)						\inlineC{1}
	\state

	\state \var{nat}{indice} \asig 0										\inlineC{1}

	\while{indice \menor Longitud(sl.gremios)}								\inlineC{1}
		\state

		\state \var{gremio}{gr} \asig sl.gremios[indice]					\inlineC{1}
		\state \var{idGrupo}{idG} \asig ObtenerIdGrupoDeAliados(sl, gr)		\inlineC{1}
		\state

		\If{idMayor \igual idG}												\inlineC{1}
			\state ModificarIdGrupoDeAliados(sl, gr, idMenor)					\inlineC{1}
		\Else \If{idMayor \menor idG}										\inlineC{1}
				\state ModificarIdGrupoDeAliados(sl, gr, idG - 1)				\inlineC{1}
			\endif
		\endif
		\state

		\state indice \asig indice + 1										\inlineC{1}
	\endwhile
}
{\#gremios}
{ Dados dos id's de grupo, a todos los gremios que pertenezcan al grupo de id mayor, se les asigna el menor. A la vez, todos los id's de grupo que sean mayores que ambos se decrementan en 1, garantizando que los id's de grupo sigan siendo consecutivos.

\hspace{10pt} Por otro lado, como las operaciones previas al ciclo, la evaluación de la guarda y su cuerpo se realizan en tiempo constante, y además el ciclo se ejecuta una vez por cada gremio del sistema, la función toma tiempo proporcional a \#gremios. }

\algoritmoI{MaximoIdGrupoDeAliados}{\param{in}{sl}{estrS}}{nat}
{
	\state \var{nat}{maxId} \asig 0									\inlineC{1}

	\state
	\state \var{nat}{indice} \asig 0								\inlineC{1}
	\while{indice \menor Longitud(sl.gruposDeAliados)}				\inlineC{1}
		\state
		
		\state maxId \asig Max(maxId, sl.gruposDeAliados[indice])	\inlineC{1}

		\state
		\state indice \asig indice + 1								\inlineC{1}
	\endwhile
	\state

	\state res \asig maxId											\inlineC{1}
}
{ \#gremios }
{ Las operaciones previas, la evaluación de la guarda y el cuerpo del ciclo se realizan en tiempo constante. Como se realiza un total de Longitud(sl.gruposDeAliados) == \#gremios iteraciones, la función lleva tiempo lineal en función de \#gremios. }

\algoritmoI{Min}{\param{in}{id1}{idGrupo}, \param{in}{id2}{idGrupo}}{idGrupo}
{
	\If{id1 \menor id2}					\inlineC{1}
		\state res \asig id1			\inlineC{1}
	\Else
		\state res \asig id2			\inlineC{1}
	\endif
}
{1}
{}

\algoritmoI{Max}{\param{in}{id1}{idGrupo}, \param{in}{id2}{idGrupo}}{idGrupo}
{
	\If{id1 \menor id2}					\inlineC{1}
		\state res \asig id2			\inlineC{1}
	\Else
		\state res \asig id1			\inlineC{1}
	\endif
}
{1}
{}