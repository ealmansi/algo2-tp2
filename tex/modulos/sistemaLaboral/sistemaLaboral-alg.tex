\algoritmoI{NuevoSistemaLaboral}{\param{in}{gs}{conj(gremio)}}{estrS}
{
	\state AsignarIds(gs)
	\state res.gremios \asig gs 						\inlineC{0}
	\state
	\state res.gruposDeAliados \asig Vacía()			\inlineC{0}
	\state InicializarGruposDeAliados(res)
}
{0}
{Asigna id's consecutivos a los gremios, comenzando en 0, y luego le asigna a cada gremio un id de grupo igual a su id propio (esto garantiza que los gremios no tengan aliados inicialmente, y que sus id's de grupo sean consecutivos, comenzando en 0). }

\algoritmoI{AliarGremios}{\param{in/out}{sl}{estrS}, \param{in}{gr1}{gremio}, \param{in}{gr2}{gremio}}{}
{
	\state \var{idGrupo}{idGrupoG1} \asig ObtenerIdGrupoDeAliados(sl, gr1)			\inlineC{0}
	\state \var{idGrupo}{idGrupoG2} \asig ObtenerIdGrupoDeAliados(sl, gr2)			\inlineC{0}
	\state 

	\If{idGrupoG1 \distinto idGrupoG2}												\inlineC{0}
		\state UnificarGruposDeAliados(sl, idGrupoG1, idGrupoG2)					\inlineC{0}
	\endif
}
{0}
{ Asegura que todos los gremios aliados a uno u otro de los gremios que contraen la alianza pasen a tener el mismo id de grupo (manteniendo la propiedad de que los id's de grupo deben ser consecutivos, comenzando en 0) }

\algoritmoI{ObtenerGremios}{\param{in}{sl}{estrS}}{conj(gremio)}
{
	\state res \asig sl.gremios								\inlineC{1}
}
{1}
{ Se devuelve el conjunto de gremios por referencia, lo cual toma tiempo constante. }

\algoritmoI{Obtener\#GruposDeAliados}{\param{in}{sl}{estrS}}{nat}
{
	\state res \asig MaximoIdGrupoDeAliados(sl)			\inlineC{0}
}
{0}
{}

\algoritmoI{ObtenerIdGrupoDeAliados}{\param{in}{sl}{estrS}, \param{in}{gr}{gremio}}{idGrupo}
{
	\state res \asig sl.gruposDeAliados[ObtenerId(gr)]			\inlineC{0}
}
{0}
{}

\algoritmoI{GuardarIdGrupoDeAliados}{\param{in/out}{sl}{estrS}, \param{in}{gr}{gremio}, \param{in}{id}{idGrupo}}{}
{
	\state sl.gruposDeAliados[ObtenerId(gr)] \asig id			\inlineC{0}
}
{0}
{}

\algoritmoI{AsignarIds}{\param{in}{gs}{conj(gremio)}}{}
{
	\state \var{nat}{id} \asig 0											\inlineC{0}
	\state

	\state \var{itConj(gremio)}{itGremios} \asig CrearIt(res.gremios)		\inlineC{0}
	\while{ HaySiguiente(itGremios) }
		\state
		
		\state GuardarId(Siguiente(itGremios), id)							\inlineC{0}
		\state id \asig id + 1												\inlineC{0}
		
		\state
		\state Avanzar(itGremios)											\inlineC{0}
	\endwhile
}
{0}
{ Asigna un id a cada gremio, comenzando en 0 y de forma consecutiva. }

\algoritmoI{InicializarGruposDeAliados}{\param{in/out}{sl}{estrS}}{}
{
	\state \var{itConj(gremio)}{itGremios} \asig CrearIt(sl.gremios)		\inlineC{0}
	\while{ HaySiguiente(itGremios) }
		\state
		
		\state \var{gremio}{gr} \asig Siguiente(itGremios)					\inlineC{0}		
		\state GuardarIdGrupoDeAliados(sl, gr, ObtenerId(gr))				\inlineC{0}

		\state
		\state Avanzar(itGremios)											\inlineC{0}
	\endwhile
}
{0}
{ Asigna un id de grupo a cada gremio del sistema, igual a su id propio. }

\algoritmoI{UnificarGruposDeAliados}
{\param{in/out}{sl}{estrS}, \param{in}{id1}{idGrupo}, \param{in}{id2}{idGrupo}}{}
{
	\state \var{idGrupo}{idMenor} \asig Min(id1, id2)						\inlineC{1}
	\state \var{idGrupo}{idMayor} \asig Max(id1, id2)						\inlineC{1}
	\state

	\state \var{nat}{indice} \asig 0										\inlineC{1}

	\while{indice \menor Longitud(sl.gremios)}								\inlineC{1}
		\state

		\state \var{gremio}{gr} \asig sl.gremios[indice]					\inlineC{1}
		\state \var{idGrupo}{idG} \asig ObtenerIdGrupoDeAliados(sl, gr)		\inlineC{1}
		\state

		\If{idMayor \igual idG}												\inlineC{1}
			\state GuardarIdGrupoDeAliados(sl, gr, idMenor)					\inlineC{1}
		\Else \If{idMayor \menor idG}										\inlineC{1}
				\state GuardarIdGrupoDeAliados(sl, gr, idG - 1)				\inlineC{1}
			\endif
		\endif
		\state

		\state indice \asig indice + 1										\inlineC{1}
	\endwhile
}
{\#gremios}
{ Dados dos id's de grupo, a todos los gremios que pertenezcan al grupo de id mayor, se les asigna el menor. A la vez, todos los id's de grupo que sean mayores que ambos se decrementan en 1, garantizando que los id's de grupo sigan siendo consecutivos.

Por otro lado, como las operaciones previas al ciclo, la evaluación de la guarda y su cuerpo se realizan en tiempo constante, y además el ciclo se ejecuta una vez por cada gremio del sistema, la función toma tiempo proporcional a \#gremios. }

\algoritmoI{MaximoIdGrupoDeAliados}{\param{in}{sl}{estrS}}{nat}
{
	\state \var{nat}{maxId} \asig 0									\inlineC{1}

	\state
	\state \var{nat}{indice} \asig 0								\inlineC{1}
	\while{indice \menor Longitud(sl.gruposDeAliados)}				\inlineC{1}
		\state
		
		\state maxId \asig Max(maxId, sl.gruposDeAliados[indice])	\inlineC{1}

		\state
		\state indice \asig indice + 1								\inlineC{1}
	\endwhile
	\state

	\state res \asig maxId											\inlineC{1}
}
{ \#gremios }
{ Las operaciones previas, la evaluación de la guarda y el cuerpo del ciclo se realizan en tiempo constante. Como se realiza un total de Longitud(sl.gruposDeAliados) == \#gremios iteraciones, la función lleva tiempo lineal en función de \#gremios. }

\algoritmoI{Min}{\param{in}{id1}{idGrupo}, \param{in}{id2}{idGrupo}}{idGrupo}
{
	\If{id1 \menor id2}					\inlineC{1}
		\state res \asig id1			\inlineC{1}
	\Else
		\state res \asig id2			\inlineC{1}
	\endif
}
{1}
{}

\algoritmoI{Max}{\param{in}{id1}{idGrupo}, \param{in}{id2}{idGrupo}}{idGrupo}
{
	\If{id1 \menor id2}					\inlineC{1}
		\state res \asig id2			\inlineC{1}
	\Else
		\state res \asig id1			\inlineC{1}
	\endif
}
{1}
{}