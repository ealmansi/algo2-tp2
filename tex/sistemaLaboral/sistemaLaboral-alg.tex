\algoritmoI{NuevoSistemaLaboral}{}{\param{}{res}{estrS}}
{
	\state res.gremios \asig Vacía()
	\state res.gruposDeAliados \asig Vacía()
}
{0}

\algoritmoIvoid{AgregarGremio}{\param{in/out}{sl}{estrS}, \param{in/out}{gr}{gremio}}
{
	\state \var{idGremio}{id} \asig ObtenerProximoIdGremio(sl)
	\state
	\state GuardarId(gr,id)
	\state sl.gremios[id] \asig \&gr
	\state sl.gruposDeAliados[id] \asig ObtenerProximoIdGrupoDeAliados(sl)
}
{0}

\algoritmoIvoid{AliarGremios}{\param{in/out}{sl}{estrS}, \param{in}{gr1}{gremio}, \param{in}{gr2}{gremio}}
{
	\state \var{idGrupo}{idGrupoG1} \asig ObtenerIdGrupoDeAliados(sl, \&gr1)
	\state \var{idGrupo}{idGrupoG2} \asig ObtenerIdGrupoDeAliados(sl, \&gr2)
	\state 
	\state UnificarGruposDeAliados(sl, idGrupoG1, idGrupoG2)
}
{0}

\algoritmoI{ObtenerGremios}{\param{in}{sl}{estrS}}{\param{}{res}{conj(puntero(gremio))}}
{
	\state res \asig Vacío()

	\state
	\state \var{nat}{indice} \asig 0
	\while{indice \menor Longitud(sl.gremios)}
		\state

		\state Agregar(res, sl.gremios[indice])

		\state
		\state indice \asig indice + 1
	\endwhile
}
{0}

\algoritmoI{Obtener\#GruposDeAliados}{\param{in}{sl}{estrS}}{\param{}{res}{nat}}
{
	\state res \asig MaximoIdGrupoDeAliados(sl)
}
{0}

\algoritmoI{ObtenerIdGrupoDeAliados}{\param{in}{sl}{estrS}, \param{in}{gr}{puntero(gremio)}}{\param{}{res}{idGrupo}}
{
	\state res \asig sl.gruposDeAliados[ObtenerId(*gr)]
}
{0}

\algoritmoIvoid{GuardarIdGrupoDeAliados}{\param{in/out}{sl}{estrS}, \param{in}{gr}{puntero(gremio)}, \param{in}{id}{idGrupo}}
{
	\state sl.gruposDeAliados[ObtenerId(*gr)] \asig id
}
{0}

\algoritmoI{ObtenerProximoIdGremio}{\param{in}{sl}{estrS}}{\param{}{res}{idGremio}}
{
	\state res \asig Longitud(sl.gremios)
}
{0}

\algoritmoI{ObtenerProximoIdGrupoDeAliados}{\param{in}{sl}{estrS}}{\param{}{res}{idGrupo}}
{
	\If{Longitud(sl.gruposDeAliados) \igual 0}
		\state res \asig 0
	\Else
		\state res \asig MaximoIdGrupoDeAliados(sl) + 1
	\endif
}
{0}

\algoritmoIvoid{UnificarGruposDeAliados}{\param{in/out}{sl}{estrS}, \param{in}{id1}{idGrupo}, \param{in}{id2}{idGrupo}}
{
	\state \var{idGrupo}{idMenor} \asig Min(id1, id2)
	\state \var{idGrupo}{idMayor} \asig Max(id1, id2)
	\state

	\state \var{nat}{indice} \asig 0

	\while{indice \menor Longitud(sl.gremios)}
		\state

		\state \var{puntero(gremio)}{gr} \asig sl.gremios[indice]
		\state \var{idGrupo}{idG} \asig ObtenerIdGrupoDeAliados(sl, gr)
		\state

		\If{idMayor \igual idG}
			\state GuardarIdGrupoDeAliados(sl, gr, idMenor)
		\Else \If{idMayor \menor idG}
				\state GuardarIdGrupoDeAliados(sl, gr, idG - 1)
			\endif
		\endif
		\state

		\state indice \asig indice + 1
	\endwhile
}
{0}

\algoritmoI{MaximoIdGrupoDeAliados}{\param{in}{sl}{estrS}}{\param{}{res}{nat}}
{
	\state \var{nat}{maxId} \asig 0

	\state
	\state \var{nat}{indice} \asig 0
	\while{indice \menor Longitud(sl.gruposDeAliados)}
		\state
		
		\state maxId \asig Max(maxId, sl.gruposDeAliados[indice])

		\state
		\state indice \asig indice + 1
	\endwhile
	\state

	\state res \asig maxId
}
{0}

\algoritmoI{Min}{\param{in}{id1}{idGrupo}, \param{in}{id2}{idGrupo}}{\param{}{res}{idGrupo}}
{
	\If{id1 \menor id2}
		\state res \asig id1
	\Else
		\state res \asig id2
	\endif
}
{0}

\algoritmoI{Max}{\param{in}{id1}{idGrupo}, \param{in}{id2}{idGrupo}}{\param{}{res}{idGrupo}}
{
	\If{id1 \menor id2}
		\state res \asig id2
	\Else
		\state res \asig id1
	\endif
}
{0}


% \algoritmoI{NuevaParitaria}
% {\param{in}{gr}{puntero(gremio)}, \param{in}{ps}{nat}, \param{in}{tp}{nat}}{\param{}{res}{estrP}}
% {
% 	\state res.gremio \asig gr	
% 	\state res.piso \asig ps
% 	\state res.tope \asig tp
% }
% {0}

% \algoritmoI{ObtenerGremio}
% {\param{in}{pa}{estrP}}{\param{}{res}{puntero(gremio)}}
% {
% 	\state res \asig pa.gremio	
% }
% {0}

% \algoritmoI{ObtenerPiso}
% {\param{in}{pa}{estrP}}{\param{}{res}{nat}}
% {
% 	\state res \asig pa.piso	
% }
% {0}

% \algoritmoI{ObtenerTope}
% {\param{in}{pa}{estrP}}{\param{}{res}{nat}}
% {
% 	\state res \asig pa.tope	
% }
% {0}


% \begin{algorithm}[H]
% \caption{iRaizAC}
% \begin{algorithmic}[1]
% \Function{iRaiz}{\param{in}{ac}{estrAC}}{$\ensuremath{\rightarrow}$ \param{}{res}{Categoria}}
% \state res $\gets$ (*(ac.raiz)).categoria \hfill //O(1)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{1}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iDameCantidad}
% \begin{algorithmic}[1]
% \Function{iDameCantidad}{\param{in}{ac}{estrAC}}{$\ensuremath{\rightarrow}$ \param{}{res}{nat}}
% \state res $\gets$ ac.cantidad \hfill //O(1)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{1}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iIdAC}
% \begin{algorithmic}[1]
% \Function{iId}{\param{in}{ac}{estrAC}, \param{in}{c}{Categoria}}{$\ensuremath{\rightarrow}$ \param{}{res}{nat}}
% \state res $\gets$ ((*obtener(c,ac.familia)).id \hfill //O(|c|)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{|c|}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iAlturaCatAC}
% \begin{algorithmic}[1]
% \Function{iAlturaCatAC}{\param{in}{ac}{estrAC}, \param{in}{c}{Categoria}}{$\ensuremath{\rightarrow}$ \param{}{res}{nat}}
% \state res $\gets$ (*obtener(c,ac.familia)).altura \hfill //O(|c|)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{|c|}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iHijosAC}
% \begin{algorithmic}[1]
% \Function{iHijosAC}{\param{in}{ac}{estrAC}, \param{in}{c}{Categoria}}{$\ensuremath{\rightarrow}$ \param{}{res}{itHijos}}
% \state res $\gets$ crearItHijos(ac,c) \hfill //O(|c|)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{|c|}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iPadreAC}
% \begin{algorithmic}[1]
% \Function{iPadreAC}{\param{in}{ac}{estrAC}, \param{in}{c}{Categoria}}{$\ensuremath{\rightarrow}$ \param{}{res}{Categoria}}
% \state res $\gets$ (*(*obtener(c,ac.familia)).padre).categoria \hfill //O(|c|)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{|c|}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iAlturaAC}
% \begin{algorithmic}[1]
% \Function{iAlturaAC}{\param{in}{ac}{estrAC}}{$\ensuremath{\rightarrow}$ \param{}{res}{nat}}
% \state res $\gets$ ac.alturaMax \hfill //O(1)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{1}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iPredecesores}
% \begin{algorithmic}[1]
% \Function{iPredecesores}{\param{in}{ac}{estrAC}, \param{in}{c}{Categoria}}{$\ensuremath{\rightarrow}$ \param{}{res}{itFamilia}}
% \state res $\gets$ crearItFamilia(ac,c) \hfill //O(|c|)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{|c|}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iNuevoAC}
% \begin{algorithmic}[1]
% \Function{iNuevoAC}{\param{in}{c}{Categoria}}{$\ensuremath{\rightarrow}$ \param{}{res}{estrAC}}
% \state res.cantidad $\gets$ 1 \hfill //O(1)
% \state datosCat tuplaA \hfill //O(1)
% \state tuplaA $\gets$ tupla(c,1,1,vacio(),Null) \hfill //O(|c|)
% \state puntero(datosCat) punt $\gets$ \&tuplaA \hfill //O(1)
% \state res.raiz $\gets$ punt \hfill //O(1)
% \state res.alturaMax $\gets$ 1 \hfill //O(1)
% \state definir(c, punt, res.familia) \hfill //O(|c|)
% \state agregarAtras(tuplaA, res.categorias) \hfill //O(1)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{|c|}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iAgregarAC}
% \begin{algorithmic}[1]
% \Function{iAgregarAC}{\param{in/out}{ac}{estrAC}, \param{in}{c}{Categoria}, \param{in}{h}{Categoria}}{}
% \state puntero(datosCat) puntPadre $\gets$ obtener(c,ac.familia) \hfill //O(|c|)
% \If{(*puntPadre).altura == ac.alturaMax} \hfill //O(1)
% \state ac.alturaMax++ \hfill //O(1)
% \endif
% \state datosCat tuplaA $\gets$ (h,ac.cantidad+1,(*puntPadre).altura+1,vacio(),puntPadre) \hfill //O(|h|)
% \state puntero(datosCat) punt $\gets$ \&tuplaA \hfill //O(1)
% \state Agregar((*puntPadre).hijos,punt) \hfill //O(1)
% \state definir(h,punt,ac.familia) \hfill //O(|h|)
% \state ac.cantidad++ \hfill //O(1)
% \state agregarAtras(tuplaA,ac.categorias) \hfill //O(1)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{|c|+|h|}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iEsta?}
% \begin{algorithmic}[1]
% \Function{iEsta?}{\param{in}{ac}{estrAC}, \param{in}{c}{Categoria}}{$\ensuremath{\rightarrow}$ \param{}{res}{bool}}
% \state res $\gets$ def?(c,ac.familia) \hfill //O(|c|)
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{|c|}
% \end{algorithm}

% \begin{algorithm}[H]
% \caption{iEsSubCategoria}
% \begin{algorithmic}[1]
% \Function{iEsSubCategoria}{\param{in}{ac}{estrAC}, \param{in}{c}{Categoria}, \param{in}{h}{Categoria}}{$\ensuremath{\rightarrow}$ \param{}{res}{bool}}
% \state res $\gets$ false \hfill //O(1)
% \If{h == c} \hfill //O(|h|)
% \state res $\gets$ true \hfill //O(1)
% \Else
% \If{h == raizAC(ac)} \hfill //O(|h|)
% \state res $\gets$ false \hfill //O(1)
% \Else
% \state puntero(datosCat) actual $\gets$ (*obtener(h,ac.familia)).padre \hfill //O(|h|)
% \state puntero(datosCat) puntC $\gets$ (*obtener(c,ac.familia)) \hfill //O(|c|)
% \while{res == false $\land$ actual $\neq$ NULL} \hfill //O(alturaAC(ac))
% \If{puntC.Id == actual.Id} \hfill //O(1)
% \state res $\gets$ true \hfill //O(1)
% \Else
% \state actual $\gets$ (*actual).padre \hfill //O(1)
% \endif
% \endwhile
% \endif
% \endif
% \EndFunction 
% \end{algorithmic}
% \hrule
% \complejidad{|h| + |c| + alturaAC(ac)}
% \end{algorithm}
